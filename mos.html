<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Taskbar with App State Management</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: #ddd;
      font-family: sans-serif;
      overflow: hidden;
    }
    #taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: #333;
      display: flex;
      align-items: center;
      padding: 0 10px;
      z-index: 1000;
    }
    .taskbar-button {
      background: #555;
      color: white;
      border: none;
      margin-right: 5px;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 14px;
      position: relative;
      transition: background 0.3s;
    }
    .taskbar-button.focused {
      background: #00aaff;
    }
    .dot {
      position: absolute;
      top: 3px;
      right: 3px;
      width: 3px;
      height: 3px;
      border-radius: 50%;
    }
    .dot.grey {
      background: grey;
    }
    .dot.green {
      background: limegreen;
    }
    .app {
      position: absolute;
      top: 50px;
      left: 50px;
      width: 300px;
      height: 200px;
      background: white;
      border: 2px solid #666;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      z-index: 1;
      touch-action: none;
      /* Only apply transitions to specific properties */
      transition: opacity 0.3s, transform 0.3s;
    }
    .app.with-transitions {
      transition: width 0.3s, height 0.3s, top 0.3s, left 0.3s, opacity 0.3s, transform 0.3s;
    }
    .app.closing {
      opacity: 0;
      transform: scale(0.8);
    }
    .app.minimizing {
      opacity: 0;
      transform: translateY(100px) scale(0.6);
    }
    .app.maximizing {
      transform: scale(1.05);
    }
    .app-header {
      background: #444;
      color: white;
      padding: 5px;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }
    .controls {
      display: flex;
      flex-direction: row;
      align-items: center;
    }
    .app-header button {
      background: transparent;
      border: none;
      color: white;
      margin-left: 5px;
      cursor: pointer;
      padding: 2px;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 3px;
      transition: background 0.2s, transform 0.2s;
    }
    .app-header button:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    .app-header button.close:hover {
      background: #ff4444;
    }
    .app-header button svg {
      width: 14px;
      height: 14px;
      fill: white;
      pointer-events: none;
      transition: all 0.2s;
    }
    .app-header button:active svg {
      transform: scale(0.8);
    }
    .app-content {
      flex: 1;
      padding: 10px;
      overflow: auto;
    }
    .minimized {
      display: none;
    }
    .focused {
      border-color: #00aaff;
      box-shadow: 0 0 10px #00aaff;
    }
    /* Resize handles */
    .resize-handle {
      position: absolute;
      background: transparent;
    }
    .resize-handle.n {
      top: -5px;
      left: 0;
      width: 100%;
      height: 10px;
      cursor: ns-resize;
    }
    .resize-handle.e {
      top: 0;
      right: -5px;
      width: 10px;
      height: 100%;
      cursor: ew-resize;
    }
    .resize-handle.s {
      bottom: -5px;
      left: 0;
      width: 100%;
      height: 10px;
      cursor: ns-resize;
    }
    .resize-handle.w {
      top: 0;
      left: -5px;
      width: 10px;
      height: 100%;
      cursor: ew-resize;
    }
    .resize-handle.ne {
      top: -5px;
      right: -5px;
      width: 10px;
      height: 10px;
      cursor: ne-resize;
    }
    .resize-handle.se {
      bottom: -5px;
      right: -5px;
      width: 10px;
      height: 10px;
      cursor: se-resize;
    }
    .resize-handle.sw {
      bottom: -5px;
      left: -5px;
      width: 10px;
      height: 10px;
      cursor: sw-resize;
    }
    .resize-handle.nw {
      top: -5px;
      left: -5px;
      width: 10px;
      height: 10px;
      cursor: nw-resize;
    }
  </style>
</head>
<body>

<div id="apps-container"></div>
<div id="taskbar"></div>

<script>
let zIndexCounter = 1;

const apps = {
  "app1": { id: "app1", name: "App 1", opened: false, focused: false, minimized: false, element: null },
  "app2": { id: "app2", name: "App 2", opened: false, focused: false, minimized: false, element: null },
  "app3": { id: "app3", name: "App 3", opened: false, focused: false, minimized: false, element: null },
  "app4": { id: "app4", name: "App 4", opened: false, focused: false, minimized: false, element: null }
};

const buttons = {};

function createTaskbarButtons() {
  const taskbar = document.getElementById('taskbar');
  Object.values(apps).forEach(app => {
    const button = document.createElement('button');
    button.className = 'taskbar-button';
    button.textContent = app.name;
    button.onclick = () => {
      if (!app.opened) {
        openApp(app);
      } else if (app.focused && !app.minimized) {
        minimizeApp(app);
      } else {
        app.minimized = false;
        app.element.classList.remove('minimized');
        focusApp(app);
      }
      updateTaskbar();
    };
    taskbar.appendChild(button);
    buttons[app.id] = button;
  });
}

function openApp(app) {
  if (app.opened) {
    focusApp(app);
    return;
  }

  const appDiv = document.createElement('div');
  appDiv.className = 'app';
  appDiv.setAttribute('data-app-id', app.id);
  appDiv.style.opacity = '0';
  appDiv.style.transform = 'scale(0.9)';
  
  appDiv.innerHTML = `
    <div class="app-header">
      <span class="title">${app.name}</span>
      <div class="controls">
        <button class="minimize" title="Minimize">
          <svg viewBox="0 0 24 24"><rect y="18" width="24" height="2"/></svg>
        </button>
        <button class="maximize" title="Maximize">
          <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" stroke="white" stroke-width="2" fill="none"/></svg>
        </button>
        <button class="close" title="Close">
          <svg viewBox="0 0 24 24"><line x1="4" y1="4" x2="20" y2="20" stroke="white" stroke-width="2"/><line x1="20" y1="4" x2="4" y2="20" stroke="white" stroke-width="2"/></svg>
        </button>
      </div>
    </div>
    <div class="app-content">
      Content of ${app.name}
    </div>
    <div class="resize-handle n"></div>
    <div class="resize-handle e"></div>
    <div class="resize-handle s"></div>
    <div class="resize-handle w"></div>
    <div class="resize-handle ne"></div>
    <div class="resize-handle se"></div>
    <div class="resize-handle sw"></div>
    <div class="resize-handle nw"></div>
  `;

  document.getElementById('apps-container').appendChild(appDiv);
  app.element = appDiv;
  app.opened = true;
  app.focused = true;
  app.minimized = false;
  
  // Opening animation
  setTimeout(() => {
    appDiv.style.opacity = '1';
    appDiv.style.transform = 'scale(1)';
  }, 10);

  appDiv.querySelector('.minimize').onclick = (e) => {
    e.stopPropagation();
    minimizeApp(app);
  };
  appDiv.querySelector('.maximize').onclick = (e) => {
    e.stopPropagation();
    maximizeApp(app);
  };
  appDiv.querySelector('.close').onclick = (e) => {
    e.stopPropagation();
    closeApp(app);
  };

  appDiv.addEventListener('mousedown', (e) => {
    if (!e.target.closest('button') && !e.target.closest('.resize-handle')) focusApp(app);
  });
  appDiv.addEventListener('touchstart', (e) => {
    if (!e.target.closest('button') && !e.target.closest('.resize-handle')) focusApp(app);
  });

  makeDraggable(app);
  makeResizable(app);
  focusApp(app);
  updateTaskbar();
}

function focusApp(app) {
  Object.values(apps).forEach(a => {
    if (a.opened && a.element) {
      a.focused = false;
      a.element.classList.remove('focused');
    }
  });

  app.focused = true;
  app.minimized = false;
  app.element.classList.remove('minimized');
  app.element.classList.add('focused');
  app.element.style.zIndex = ++zIndexCounter;
  updateTaskbar();
}

function minimizeApp(app) {
  app.element.classList.add('with-transitions');
  app.element.classList.add('minimizing');
  
  setTimeout(() => {
    app.minimized = true;
    app.focused = false;
    app.element.classList.add('minimized');
    app.element.classList.remove('minimizing');
    app.element.classList.remove('with-transitions');
    updateTaskbar();
  }, 300);
}

function maximizeApp(app) {
  const appDiv = app.element;
  
  // Add transitions for this operation
  appDiv.classList.add('with-transitions');
  
  if (appDiv.dataset.maximized === "true") {
    // Store current dimensions for animation
    const maxWidth = appDiv.style.width;
    const maxHeight = appDiv.style.height;
    
    // Add maximizing class for transition effect
    appDiv.classList.add('maximizing');
    
    // Restore previous dimensions after animation
    setTimeout(() => {
      appDiv.style.width = '300px';
      appDiv.style.height = '200px';
      appDiv.style.top = '50px';
      appDiv.style.left = '50px';
      appDiv.dataset.maximized = "false";
      
      setTimeout(() => {
        appDiv.classList.remove('maximizing');
        // Remove transitions after animation completes
        appDiv.classList.remove('with-transitions');
      }, 300);
    }, 10);
  } else {
    // Store current dimensions for possible restore
    appDiv.dataset.prevWidth = appDiv.style.width || '300px';
    appDiv.dataset.prevHeight = appDiv.style.height || '200px';
    appDiv.dataset.prevTop = appDiv.style.top || '50px';
    appDiv.dataset.prevLeft = appDiv.style.left || '50px';
    
    // Add maximizing class for transition effect
    appDiv.classList.add('maximizing');
    
    // Set to maximized dimensions
    setTimeout(() => {
      appDiv.style.width = '100%';
      appDiv.style.height = `calc(100% - 40px)`;
      appDiv.style.top = '0';
      appDiv.style.left = '0';
      appDiv.dataset.maximized = "true";
      
      setTimeout(() => {
        appDiv.classList.remove('maximizing');
        // Remove transitions after animation completes
        appDiv.classList.remove('with-transitions');
      }, 300);
    }, 10);
  }
  
  focusApp(app);
}

function closeApp(app) {
  if (app.element) {
    app.element.classList.add('with-transitions');
    app.element.classList.add('closing');
    
    setTimeout(() => {
      app.element.remove();
      app.opened = false;
      app.focused = false;
      app.minimized = false;
      app.element = null;
      updateTaskbar();
    }, 300);
  }
}

function updateTaskbar() {
  Object.values(apps).forEach(app => {
    const button = buttons[app.id];
    button.classList.remove('focused');
    const oldDot = button.querySelector('.dot');
    if (oldDot) oldDot.remove();

    if (!app.opened) {
      // Closed app: no indicator
    } else if (app.minimized) {
      const dot = document.createElement('div');
      dot.className = 'dot grey';
      button.appendChild(dot);
    } else if (app.focused) {
      button.classList.add('focused');
    } else {
      const dot = document.createElement('div');
      dot.className = 'dot green';
      button.appendChild(dot);
    }
  });
}

function makeDraggable(app) {
  const appDiv = app.element;
  const header = appDiv.querySelector('.app-header');
  let offsetX = 0, offsetY = 0, isDown = false;

  function startDrag(x, y) {
    if (appDiv.dataset.maximized === "true") return;
    isDown = true;
    
    // Remove transitions when starting to drag
    appDiv.classList.remove('with-transitions');
    
    offsetX = x - appDiv.offsetLeft;
    offsetY = y - appDiv.offsetTop;
  }

  function moveDrag(x, y) {
    if (isDown) {
      let newLeft = x - offsetX;
      let newTop = y - offsetY;
      newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - appDiv.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, window.innerHeight - appDiv.offsetHeight - 40));
      appDiv.style.left = newLeft + 'px';
      appDiv.style.top = newTop + 'px';
    }
  }

  function stopDrag() {
    isDown = false;
  }

  header.addEventListener('mousedown', (e) => {
    if (e.target.closest('button')) return;
    e.preventDefault();
    startDrag(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
  document.addEventListener('mouseup', stopDrag);

  header.addEventListener('touchstart', (e) => {
    if (e.target.closest('button')) return;
    startDrag(e.touches[0].clientX, e.touches[0].clientY);
  });
  document.addEventListener('touchmove', (e) => {
    if (isDown) {
      e.preventDefault();
      moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, { passive: false });
  document.addEventListener('touchend', stopDrag);
}

function makeResizable(app) {
  const appDiv = app.element;
  const handles = appDiv.querySelectorAll('.resize-handle');
  
  handles.forEach(handle => {
    let startX, startY, startWidth, startHeight, startLeft, startTop;
    let resizing = false;
    
    function startResize(e) {
      if (appDiv.dataset.maximized === "true") return;
      
      resizing = true;
      
      // Remove transitions when starting to resize
      appDiv.classList.remove('with-transitions');
      
      startX = e.clientX || e.touches[0].clientX;
      startY = e.clientY || e.touches[0].clientY;
      startWidth = parseInt(document.defaultView.getComputedStyle(appDiv).width, 10);
      startHeight = parseInt(document.defaultView.getComputedStyle(appDiv).height, 10);
      startLeft = parseInt(document.defaultView.getComputedStyle(appDiv).left, 10);
      startTop = parseInt(document.defaultView.getComputedStyle(appDiv).top, 10);
      
      e.preventDefault();
      focusApp(app);
    }
    
    function doResize(e) {
      if (!resizing) return;
      
      const clientX = e.clientX || e.touches[0].clientX;
      const clientY = e.clientY || e.touches[0].clientY;
      
      const dx = clientX - startX;
      const dy = clientY - startY;
      
      const direction = handle.className.replace('resize-handle', '').trim();
      
      // Minimum window size
      const minWidth = 200;
      const minHeight = 100;
      
      if (direction.includes('e')) {
        const newWidth = startWidth + dx;
        if (newWidth >= minWidth) {
          appDiv.style.width = newWidth + 'px';
        }
      }
      
      if (direction.includes('s')) {
        const newHeight = startHeight + dy;
        if (newHeight >= minHeight) {
          appDiv.style.height = newHeight + 'px';
        }
      }
      
      if (direction.includes('w')) {
        const newWidth = startWidth - dx;
        if (newWidth >= minWidth) {
          appDiv.style.width = newWidth + 'px';
          appDiv.style.left = startLeft + dx + 'px';
        }
      }
      
      if (direction.includes('n')) {
        const newHeight = startHeight - dy;
        if (newHeight >= minHeight) {
          appDiv.style.height = newHeight + 'px';
          appDiv.style.top = startTop + dy + 'px';
        }
      }
    }
    
    function stopResize() {
      resizing = false;
    }
    
    handle.addEventListener('mousedown', startResize);
    handle.addEventListener('touchstart', startResize);
    
    document.addEventListener('mousemove', doResize);
    document.addEventListener('touchmove', doResize, { passive: false });
    
    document.addEventListener('mouseup', stopResize);
    document.addEventListener('touchend', stopResize);
  });
}

createTaskbarButtons();
</script>

</body>
</html>
